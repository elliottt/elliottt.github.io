
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Serenade in Haskell - Stuff and Things</title>
  <meta name="author" content="Trevor Elliott">

  
  <meta name="description" content="One of the things that I think is great about Haskell is the way that you can
use the language to design new syntax. After reading
a quick &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://elliottt.github.io/blog/2014/05/07/serenade-in-haskell/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Stuff and Things" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Stuff and Things</a></h1>
  
    <h2>Probably just programming stuff</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:elliottt.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Serenade in Haskell</h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-05-07T00:00:00-07:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>One of the things that I think is great about Haskell is the way that you can
use the language to design new syntax.  After reading
<a href="http://elabs.se/blog/33-why-serenade">a quick introduction to Serenade.js</a>, one of the features that caught
my eye was their templating system.  It has a fairly elegant interface that
provides a concise language for generating HTML, though it seems like a
heavyweight solution, as it requires implementing a parser.</p>

<p>Upon closer inspection the examples provided seemed to be presenting a few key
combinators for constructing html.  After a bit of scaffolding, I&rsquo;ll demonstrate
my approach to replicating their examples in Haskell.  Just to be clear, this
isn&rsquo;t meant as a replacement, or a justification for templating in your source
language, but rather just an exploration of a Haskell embedding.</p>

<h2>Preliminaries</h2>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="cm">{-# LANGUAGE OverloadedStrings #-}</span>
</span><span class='line'><span class="kr">module</span> <span class="nn">Serenade</span> <span class="kr">where</span>
</span><span class='line'>
</span><span class='line'><span class="kr">import</span> <span class="nn">Text.PrettyPrint.HughesPJ</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>If you don&rsquo;t already know the pretty package on hackage, it&rsquo;s worth learning.
Many of the unpleasant tasks of generating strings can be boiled down to elegant
uses of the combinators it provides.</em></p>

<p>The type that the pretty package defines for pretty-printed documents is the
<code>Doc</code> type.  As I am going to be rendering out HTML as text in my <code>Serenade</code>
type, it&rsquo;s natural to make it a synonym of the <code>Doc</code> type.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Serenade</span> <span class="ow">=</span> <span class="kt">Doc</span>
</span></code></pre></td></tr></table></div></figure>


<p>I&rsquo;ve simplified attributes to key/value pairs, which works well for my
small example.  Their pretty printing just involves printing the name as text,
followed by an &lsquo;=&rsquo; character, then the double quoted value.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Attr</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">String</span><span class="p">,</span><span class="kt">String</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">attr</span> <span class="ow">::</span> <span class="kt">Attr</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span>
</span><span class='line'><span class="nf">attr</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="ow">=</span> <span class="n">text</span> <span class="n">n</span> <span class="o">&lt;&gt;</span> <span class="n">char</span> <span class="sc">&#39;=&#39;</span> <span class="o">&lt;&gt;</span> <span class="n">doubleQuotes</span> <span class="p">(</span><span class="n">text</span> <span class="n">v</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nf">attrs</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Attr</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span>
</span><span class='line'><span class="nf">attrs</span>  <span class="ow">=</span> <span class="n">hsep</span> <span class="o">.</span> <span class="n">map</span> <span class="n">attr</span>
</span></code></pre></td></tr></table></div></figure>


<p>Tags are implemented as functions from their attributes and a child document, to
a new document.  The <code>tag</code> primitive is a function that takes a boolean value
that specifies if its content should be nested, or on the same line, and the
name of the tag as a <code>String</code>.  When the resulting <code>Tag</code> is used, it prints out
open/close pairs of tags with their attributes, optionally placing the child
content of the tag on a new line, and indenting it by two spaces when it is.</p>

<p>There is currently no notion of a empty tag, such as <code>&lt;br /&gt;</code>, though it would
be easy to generate that tag when the child argument was empty.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="kr">type</span> <span class="kt">Tag</span> <span class="ow">=</span> <span class="p">[</span><span class="kt">Attr</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span>
</span><span class='line'>
</span><span class='line'><span class="nf">tag</span> <span class="ow">::</span> <span class="kt">Bool</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Tag</span>
</span><span class='line'><span class="nf">tag</span> <span class="n">nl</span> <span class="n">name</span> <span class="n">as</span> <span class="n">child</span> <span class="ow">=</span>
</span><span class='line'>     <span class="n">char</span> <span class="sc">&#39;&lt;&#39;</span> <span class="o">&lt;&gt;</span> <span class="n">text</span> <span class="n">name</span> <span class="o">&lt;+&gt;</span> <span class="n">attrs</span> <span class="n">as</span> <span class="o">&lt;&gt;</span> <span class="n">char</span> <span class="sc">&#39;&gt;&#39;</span>
</span><span class='line'>  <span class="o">^^</span> <span class="n">nest</span> <span class="mi">2</span> <span class="n">child</span>
</span><span class='line'>  <span class="o">^^</span> <span class="n">text</span> <span class="s">&quot;&lt;/&quot;</span> <span class="o">&lt;&gt;</span> <span class="n">text</span> <span class="n">name</span> <span class="o">&lt;&gt;</span> <span class="n">char</span> <span class="sc">&#39;&gt;&#39;</span>
</span><span class='line'>  <span class="kr">where</span>
</span><span class='line'>  <span class="kr">infixr</span> <span class="mi">0</span> <span class="o">^^</span>
</span><span class='line'>  <span class="p">(</span><span class="o">^^</span><span class="p">)</span> <span class="o">|</span> <span class="n">nl</span>        <span class="ow">=</span> <span class="p">(</span><span class="o">$$</span><span class="p">)</span>
</span><span class='line'>       <span class="o">|</span> <span class="n">otherwise</span> <span class="ow">=</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Combinators</h2>

<p>One of the things that struck me about the Serenade templates was their
simplicity: you don&rsquo;t write out the open/close tag pairs,
relying on layout to denote blocks.  Being a Haskell programmer, this just
seemed right.  Let&rsquo;s start by adding a few tag definitions so that the rest of
the examples have some motivation:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">ul</span><span class="p">,</span> <span class="n">li</span><span class="p">,</span> <span class="n">h1</span> <span class="ow">::</span> <span class="kt">Tag</span>
</span><span class='line'><span class="nf">ul</span> <span class="ow">=</span> <span class="n">tag</span> <span class="kt">True</span>  <span class="s">&quot;ul&quot;</span>
</span><span class='line'><span class="nf">li</span> <span class="ow">=</span> <span class="n">tag</span> <span class="kt">False</span> <span class="s">&quot;li&quot;</span>
</span><span class='line'><span class="nf">h1</span> <span class="ow">=</span> <span class="n">tag</span> <span class="kt">False</span> <span class="s">&quot;h1&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Attributes</h3>

<p>The first example that caught my eye was the difference between using a tag with
a list of attributes, and using a tag with a specific attribute: <code>id</code>.  There
are two flavors of syntax in Serenade to support this functionality, the most
general form first:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">ul</span><span class="p">[</span><span class="n">id</span><span class="ow">=</span><span class="s">&quot;x&quot;</span><span class="p">]</span> <span class="o">...</span>
</span><span class='line'><span class="nf">ul</span><span class="o">#</span><span class="s">&quot;x&quot;</span> <span class="o">...</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the first example, you are just applying the <code>ul</code> tag to a list list of
attributes, whereas in the second example, you&rsquo;re using some special syntax to
set only the <code>id</code> attribute.  I&rsquo;ve chosen to implement this as a function that
takes something a little more general than the <code>Tag</code> type specified above, as
there&rsquo;s no reason to rule out other uses of this pattern.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="o">#</span><span class="p">)</span> <span class="ow">::</span> <span class="p">([</span><span class="kt">Attr</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="n">a</span>
</span><span class='line'><span class="nf">k</span> <span class="o">#</span> <span class="n">i</span> <span class="ow">=</span> <span class="n">k</span> <span class="p">[(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">)]</span>
</span><span class='line'>
</span><span class='line'><span class="nf">attr_example1</span> <span class="ow">=</span> <span class="n">ul</span> <span class="p">[(</span><span class="s">&quot;id&quot;</span><span class="p">,</span> <span class="s">&quot;x&quot;</span><span class="p">)]</span>
</span><span class='line'><span class="nf">attr_example2</span> <span class="ow">=</span> <span class="n">ul</span> <span class="o">#</span> <span class="s">&quot;x&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you recall the definition of the <code>Tag</code> synonym, you can substitute
<code>Serenade -&gt; Serenade</code> for <code>a</code> in the type of <code>(#)</code>, and see that it can quite
easily be used as something of type <code>Tag -&gt; String -&gt; Serenade</code>.</p>

<h3>Variables</h3>

<p>In Serenade, variables are used by prefixing an identifier with a <code>@</code> character.
For example, if I have the <code>name</code> variable in scope, and would like to use it in
the body of an <code>li</code> tag, I can do this with the following snippet:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">li</span> <span class="kt">Hello</span><span class="p">,</span> <span class="n">my</span> <span class="n">name</span> <span class="n">is</span> <span class="o">@</span><span class="n">name</span>
</span></code></pre></td></tr></table></div></figure>


<p>The way that I might approach this in Haskell is to view <code>@</code> as something that
joins a piece of text with the value of a variable.  Assuming that all
variables in Serenade contain strings, this can be viewed as a combinator that
takes some <code>Serenade</code> thing on the left, and a variable that contains a <code>String</code>
on the right:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="p">(</span><span class="o">@@</span><span class="p">)</span> <span class="ow">::</span> <span class="kt">Serenade</span> <span class="ow">-&gt;</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span>
</span><span class='line'><span class="nf">l</span> <span class="o">@@</span> <span class="n">r</span> <span class="ow">=</span> <span class="n">l</span> <span class="o">&lt;&gt;</span> <span class="n">text</span> <span class="n">r</span>
</span></code></pre></td></tr></table></div></figure>


<p>Thus, the original example that uses the <code>li</code> tag can be turned into a function
that expects to have its <code>name</code> value provided.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">li_example</span> <span class="ow">::</span> <span class="kt">String</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span>
</span><span class='line'><span class="nf">li_example</span> <span class="n">name</span> <span class="ow">=</span> <span class="n">li</span> <span class="kt">[]</span> <span class="p">(</span><span class="s">&quot;Hello, my name is &quot;</span> <span class="o">@@</span><span class="n">name</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Modulo the extra <code>@</code> symbol to avoid the built-in use of <code>@</code> in Haskell, this
conveys the intent of the original serenade template.</p>

<h3>Collections</h3>

<p>Serenade provides a way to, given a collection of key/value structures, map a
serenade template over each structure.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">ul</span><span class="o">#</span><span class="n">comments</span>
</span><span class='line'>  <span class="o">-</span> <span class="n">collection</span> <span class="o">@</span><span class="n">comments</span>
</span><span class='line'>      <span class="n">li</span> <span class="o">@</span><span class="n">title</span>
</span></code></pre></td></tr></table></div></figure>


<p>As a Haskell programmer, this seems like the <code>map</code> function, but with a little
bit of extra information about how to put together the results.  The <code>vcat</code>
function from the pretty library covers how we&rsquo;d like to join together the
documents generated from each element of the list, joining them together on
separate lines.  As a result, the Haskell implementation of the collection
function in Serenade should end up being just as powerful: anything that you
can make into a <code>Serenade</code> thing, you can lift over lists.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">collection</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Serenade</span>
</span><span class='line'><span class="nf">collection</span> <span class="n">as</span> <span class="n">k</span> <span class="ow">=</span> <span class="n">vcat</span> <span class="p">(</span><span class="n">map</span> <span class="n">k</span> <span class="n">as</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, the example above can be encoded using the new <code>collection</code> combinator as
such, using the <code>text</code> function from the pretty library to turn the title string
into a Serenade document.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">col_example</span> <span class="n">comments</span> <span class="ow">=</span> <span class="n">ul</span> <span class="o">#</span> <span class="s">&quot;comments&quot;</span>
</span><span class='line'>                       <span class="o">$</span> <span class="n">collection</span> <span class="n">comments</span>
</span><span class='line'>                       <span class="o">$</span> <span class="nf">\</span><span class="n">title</span> <span class="ow">-&gt;</span> <span class="n">li</span> <span class="kt">[]</span> <span class="p">(</span><span class="n">text</span> <span class="n">title</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Ignoring the lambda, and the introduction of the comments as an argument to the
example, this looks quite similar to the example in the Serenade templating
language.  Focusing on the lambda, the programmer now has control over the
naming of the fields in the collection; in Serenade, you would be coupled to the
field names defined by the code calling the template, whereas in the Haskell
version, the programmer gets to use normal conventions introduce names
that are convenient to them.</p>

<p>The neat thing about the <code>collection</code> combinator defined in Haskell is that it
only cares about the fact that you give it a list of things, and a way to turn
an individual thing into a <code>Serenade</code> thing.  If you wanted  to take a list of
lists that contained titles, and flatten them into a single list of titles, you
could modify <code>col_example</code> to look like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='haskell'><span class='line'><span class="nf">col_of</span> <span class="n">cols</span> <span class="ow">=</span> <span class="n">ul</span> <span class="o">#</span> <span class="s">&quot;cols&quot;</span>
</span><span class='line'>            <span class="o">$</span> <span class="n">collection</span> <span class="n">cols</span>               <span class="c1">-- outer collection</span>
</span><span class='line'>            <span class="o">$</span> <span class="nf">\</span> <span class="n">col</span> <span class="ow">-&gt;</span> <span class="n">collection</span> <span class="n">col</span>       <span class="c1">-- inner collection</span>
</span><span class='line'>            <span class="o">$</span> <span class="nf">\</span> <span class="n">title</span> <span class="ow">-&gt;</span> <span class="n">li</span> <span class="kt">[]</span> <span class="p">(</span><span class="n">text</span> <span class="n">title</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now each item of the outer collection is passed again to another use of the
<code>collection</code> combinator, emitting one <code>li</code> tag for each inner title.  When given
the list <code>[ ["a"], ["b", "c"] ]</code>, the <code>col_of</code> function will produce the HTML:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='html'><span class='line'><span class="nt">&lt;ul</span> <span class="na">id=</span><span class="s">&quot;cols&quot;</span><span class="nt">&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;</span>a<span class="nt">&lt;/li&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;</span>b<span class="nt">&lt;/li&gt;</span>
</span><span class='line'>  <span class="nt">&lt;li&gt;</span>c<span class="nt">&lt;/li&gt;</span>
</span><span class='line'><span class="nt">&lt;/ul&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Conclusion</h2>

<p>It&rsquo;s amazing what you can do with just functions in Haskell. Careful attention
by the language designers to things like name scope mean that you no longer need
to rely on the names that someone else has chosen, you can choose your own
names and expect them to remain stable.  Templates written in the Haskell
Serenade approximation outlined above also benefit from Haskell&rsquo;s type system,
in that we&rsquo;re not bound to viewing everything as a hash of values: we can write
functions that traverse structures in a more meaningful way, without falling
back on hash tables.</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Trevor Elliott</span></span>

      








  


<time datetime="2014-05-07T00:00:00-07:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/haskell/'>haskell</a>, <a class='category' href='/blog/categories/serenade/'>serenade</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://elliottt.github.io/blog/2014/05/07/serenade-in-haskell/" data-via="" data-counturl="http://elliottt.github.io/blog/2014/05/07/serenade-in-haskell/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2013/02/22/vim-mapping-context/" title="Previous Post: Vim Mapping Context">&laquo; Vim Mapping Context</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/05/17/private-dhcp/" title="Next Post: Private DHCP">Private DHCP &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/08/27/vim-find-file/">Vim's `findfile` function</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/03/04/debug-console-on-xen/">Debug Console on Xen</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/17/private-dhcp/">Private DHCP</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/07/serenade-in-haskell/">Serenade in Haskell</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/02/22/vim-mapping-context/">Vim Mapping Context</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/elliottt">@elliottt</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'elliottt',
            count: 10,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - Trevor Elliott -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
